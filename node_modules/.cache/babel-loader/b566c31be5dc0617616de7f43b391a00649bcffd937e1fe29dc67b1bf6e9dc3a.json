{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\link4\\\\OneDrive\\\\Desktop\\\\RAGlocal\\\\src\\\\components\\\\VoiceInput.tsx\",\n  _s = $RefreshSig$();\nimport { useState, useRef } from \"react\";\nimport { Mic, StopCircle } from \"lucide-react\";\nimport * as React from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const VoiceInput = ({\n  onTranscription,\n  onBotResponse\n}) => {\n  _s();\n  const [recording, setRecording] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const mediaRecorder = useRef(null);\n  const audioChunks = useRef([]);\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      mediaRecorder.current = new MediaRecorder(stream);\n      mediaRecorder.current.ondataavailable = e => {\n        audioChunks.current.push(e.data);\n      };\n      mediaRecorder.current.start();\n      setRecording(true);\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err);\n    }\n  };\n  const stopRecording = async () => {\n    if (!mediaRecorder.current) return;\n    mediaRecorder.current.stop();\n    setRecording(false);\n    mediaRecorder.current.onstop = async () => {\n      setLoading(true);\n      const audioBlob = new Blob(audioChunks.current, {\n        type: \"audio/webm\"\n      });\n      audioChunks.current = [];\n      try {\n        const formData = new FormData();\n        formData.append(\"audio\", audioBlob, \"query.webm\");\n        const response = await fetch(\"/api/voice-query\", {\n          method: \"POST\",\n          body: formData\n        });\n        const data = await response.json();\n\n        // Show the user's question as soon as it's transcribed\n        if (data.question) {\n          onTranscription(data.question);\n        }\n\n        // Show the bot's response (text and audio) when ready\n        onBotResponse(data.question, data.answer, data.audio);\n      } catch (err) {\n        console.error(\"Voice query failed:\", err);\n      } finally {\n        setLoading(false);\n      }\n    };\n  };\n  return /*#__PURE__*/_jsxDEV(\"button\", {\n    onClick: recording ? stopRecording : startRecording,\n    className: \"p-2 rounded-full bg-blue-100 hover:bg-blue-200 transition-colors\",\n    disabled: loading,\n    title: recording ? \"Stop recording\" : \"Start voice query\",\n    children: recording ? /*#__PURE__*/_jsxDEV(StopCircle, {\n      className: \"h-6 w-6 text-red-600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(Mic, {\n      className: \"h-6 w-6 text-blue-600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 72,\n    columnNumber: 5\n  }, this);\n};\n_s(VoiceInput, \"GZLfqwUnoUQDfk+Jmk2Kue8Y0Nw=\");\n_c = VoiceInput;\nvar _c;\n$RefreshReg$(_c, \"VoiceInput\");","map":{"version":3,"names":["useState","useRef","Mic","StopCircle","React","jsxDEV","_jsxDEV","VoiceInput","onTranscription","onBotResponse","_s","recording","setRecording","loading","setLoading","mediaRecorder","audioChunks","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","current","MediaRecorder","ondataavailable","e","push","data","start","err","console","error","stopRecording","stop","onstop","audioBlob","Blob","type","formData","FormData","append","response","fetch","method","body","json","question","answer","onClick","className","disabled","title","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/link4/OneDrive/Desktop/RAGlocal/src/components/VoiceInput.tsx"],"sourcesContent":["import { useState, useRef } from \"react\";\r\nimport { Mic, StopCircle } from \"lucide-react\";\r\nimport * as React from \"react\";\r\ninterface VoiceInputProps {\r\n  onTranscription: (question: string) => void;\r\n  onBotResponse: (question: string, answer: string, audio: string) => void;\r\n}\r\n\r\nexport const VoiceInput: React.FC<VoiceInputProps> = ({\r\n  onTranscription,\r\n  onBotResponse,\r\n}) => {\r\n  const [recording, setRecording] = useState(false);\r\n  const [loading, setLoading] = useState(false);\r\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\r\n  const audioChunks = useRef<Blob[]>([]);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      mediaRecorder.current = new MediaRecorder(stream);\r\n\r\n      mediaRecorder.current.ondataavailable = (e) => {\r\n        audioChunks.current.push(e.data);\r\n      };\r\n\r\n      mediaRecorder.current.start();\r\n      setRecording(true);\r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n    }\r\n  };\r\n\r\n  const stopRecording = async () => {\r\n    if (!mediaRecorder.current) return;\r\n\r\n    mediaRecorder.current.stop();\r\n    setRecording(false);\r\n\r\n    mediaRecorder.current.onstop = async () => {\r\n      setLoading(true);\r\n      const audioBlob = new Blob(audioChunks.current, { type: \"audio/webm\" });\r\n      audioChunks.current = [];\r\n\r\n      try {\r\n        const formData = new FormData();\r\n        formData.append(\"audio\", audioBlob, \"query.webm\");\r\n\r\n        const response = await fetch(\"/api/voice-query\", {\r\n          method: \"POST\",\r\n          body: formData,\r\n        });\r\n\r\n        const data = await response.json();\r\n\r\n        // Show the user's question as soon as it's transcribed\r\n        if (data.question) {\r\n          onTranscription(data.question);\r\n        }\r\n\r\n        // Show the bot's response (text and audio) when ready\r\n        onBotResponse(data.question, data.answer, data.audio);\r\n      } catch (err) {\r\n        console.error(\"Voice query failed:\", err);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n  };\r\n\r\n  return (\r\n    <button\r\n      onClick={recording ? stopRecording : startRecording}\r\n      className=\"p-2 rounded-full bg-blue-100 hover:bg-blue-200 transition-colors\"\r\n      disabled={loading}\r\n      title={recording ? \"Stop recording\" : \"Start voice query\"}\r\n    >\r\n      {recording ? (\r\n        <StopCircle className=\"h-6 w-6 text-red-600\" />\r\n      ) : (\r\n        <Mic className=\"h-6 w-6 text-blue-600\" />\r\n      )}\r\n    </button>\r\n  );\r\n};\r\n"],"mappings":";;AAAA,SAASA,QAAQ,EAAEC,MAAM,QAAQ,OAAO;AACxC,SAASC,GAAG,EAAEC,UAAU,QAAQ,cAAc;AAC9C,OAAO,KAAKC,KAAK,MAAM,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAM/B,OAAO,MAAMC,UAAqC,GAAGA,CAAC;EACpDC,eAAe;EACfC;AACF,CAAC,KAAK;EAAAC,EAAA;EACJ,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGZ,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACa,OAAO,EAAEC,UAAU,CAAC,GAAGd,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAMe,aAAa,GAAGd,MAAM,CAAuB,IAAI,CAAC;EACxD,MAAMe,WAAW,GAAGf,MAAM,CAAS,EAAE,CAAC;EAEtC,MAAMgB,cAAc,GAAG,MAAAA,CAAA,KAAY;IACjC,IAAI;MACF,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzEP,aAAa,CAACQ,OAAO,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAEjDH,aAAa,CAACQ,OAAO,CAACE,eAAe,GAAIC,CAAC,IAAK;QAC7CV,WAAW,CAACO,OAAO,CAACI,IAAI,CAACD,CAAC,CAACE,IAAI,CAAC;MAClC,CAAC;MAEDb,aAAa,CAACQ,OAAO,CAACM,KAAK,CAAC,CAAC;MAC7BjB,YAAY,CAAC,IAAI,CAAC;IACpB,CAAC,CAAC,OAAOkB,GAAG,EAAE;MACZC,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAEF,GAAG,CAAC;IACnD;EACF,CAAC;EAED,MAAMG,aAAa,GAAG,MAAAA,CAAA,KAAY;IAChC,IAAI,CAAClB,aAAa,CAACQ,OAAO,EAAE;IAE5BR,aAAa,CAACQ,OAAO,CAACW,IAAI,CAAC,CAAC;IAC5BtB,YAAY,CAAC,KAAK,CAAC;IAEnBG,aAAa,CAACQ,OAAO,CAACY,MAAM,GAAG,YAAY;MACzCrB,UAAU,CAAC,IAAI,CAAC;MAChB,MAAMsB,SAAS,GAAG,IAAIC,IAAI,CAACrB,WAAW,CAACO,OAAO,EAAE;QAAEe,IAAI,EAAE;MAAa,CAAC,CAAC;MACvEtB,WAAW,CAACO,OAAO,GAAG,EAAE;MAExB,IAAI;QACF,MAAMgB,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;QAC/BD,QAAQ,CAACE,MAAM,CAAC,OAAO,EAAEL,SAAS,EAAE,YAAY,CAAC;QAEjD,MAAMM,QAAQ,GAAG,MAAMC,KAAK,CAAC,kBAAkB,EAAE;UAC/CC,MAAM,EAAE,MAAM;UACdC,IAAI,EAAEN;QACR,CAAC,CAAC;QAEF,MAAMX,IAAI,GAAG,MAAMc,QAAQ,CAACI,IAAI,CAAC,CAAC;;QAElC;QACA,IAAIlB,IAAI,CAACmB,QAAQ,EAAE;UACjBvC,eAAe,CAACoB,IAAI,CAACmB,QAAQ,CAAC;QAChC;;QAEA;QACAtC,aAAa,CAACmB,IAAI,CAACmB,QAAQ,EAAEnB,IAAI,CAACoB,MAAM,EAAEpB,IAAI,CAACN,KAAK,CAAC;MACvD,CAAC,CAAC,OAAOQ,GAAG,EAAE;QACZC,OAAO,CAACC,KAAK,CAAC,qBAAqB,EAAEF,GAAG,CAAC;MAC3C,CAAC,SAAS;QACRhB,UAAU,CAAC,KAAK,CAAC;MACnB;IACF,CAAC;EACH,CAAC;EAED,oBACER,OAAA;IACE2C,OAAO,EAAEtC,SAAS,GAAGsB,aAAa,GAAGhB,cAAe;IACpDiC,SAAS,EAAC,kEAAkE;IAC5EC,QAAQ,EAAEtC,OAAQ;IAClBuC,KAAK,EAAEzC,SAAS,GAAG,gBAAgB,GAAG,mBAAoB;IAAA0C,QAAA,EAEzD1C,SAAS,gBACRL,OAAA,CAACH,UAAU;MAAC+C,SAAS,EAAC;IAAsB;MAAAI,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,gBAE/CnD,OAAA,CAACJ,GAAG;MAACgD,SAAS,EAAC;IAAuB;MAAAI,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE;EACzC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACK,CAAC;AAEb,CAAC;AAAC/C,EAAA,CA5EWH,UAAqC;AAAAmD,EAAA,GAArCnD,UAAqC;AAAA,IAAAmD,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}